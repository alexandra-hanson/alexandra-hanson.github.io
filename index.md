# CSCI 5611: Project 1 -- Geometry & Planning

## Group

* Alexandra Hanson (hans7203)

## Attempted features

*Disclaimer*: I believe I should have attempted one more feature since I am a graduate student, but I was quite ill for the past week and a half so I was short on time. I have done the following features:

* Single agent navigation
* User scenario editing
* Realtime user interaction
* Multiple agents planning
* Crowd simulation

## About (& some reflection)

This is a project for CSCI 5611: Animation and Planning in Games that uses geometric modeling planning and
anticipation techniques for intelligent collision avoidance.

I use a path planning library that implements uniform cost search to model paths for my agents (which are just little blue circles in my animation below). I also do a thing in my path planning library where I iterate through the path generated by UCS and figure out if I can skip any nodes in the current path to optimize.

For the simulation, I created `Agent` and `Target` classes to keep track of information like position, size, velocity, etc. I wanted to do the same for obstacles but I found that to be a little more complicated for some reason I cannot recall so I left these as circlePos[] and circleRad[]. I ended up using global arrays of agents, targets, starting positions, and goal positions so that I could keep track of this data for multiple agents at a time. `curPath` from the original testing file became an integer array list of `curPaths`. Note that in this case a "target" is the next node in the path for the agent to visit. This may be the goal or some other node along the way.

I used the TTC forces strategy from class to implement crowd simulation. I do this within the `Agent` class since agents are the only moving components (the function is `computeAgentForces`). I think this is working pretty well... it could probably be better but it is certainly better than I thought I would get it when I woke up this morning. I have a high-ish `k_avoid` value for other agents but this gets much larger if the agents are about to collide. I also added avoidance forces for obstacles -- if an agent is about the collide with an obstacle, it stops and recomputes its path.

The main issue I ran into was how to compute the TTC forces. My agents did not do a very good job of avoiding each other initially. What really helped was increasing `k_avoid` by A LOT if the agents are about to collide. I actually just figured this out like five hours before the deadline so I am pretty proud of myself. What also helped was recomputing the path if an agent is about t0 collide with an obstacle. That really seemed to do the trick.

I have both real-time user interaction and user-scenario editing. These both happen during run time. They are specifically as follows:

* Real-time user interaction
  * The user can move the purple obstacle around with the arrow keys to adjust the agents' paths. The obstacle cannot be moved over the start position, goal position, or agent itself -- only in the way of its path.
* User-scenario editing
  * The user can increment the number of obstacles by pressing "o" and decrement the number of obstacles by pressing "p"
  * The user can increment the number of agents by left-clicking the mouse and decrement the number of agents by right-clicking the mouse

For visuals and clarity, I left in the path that is drawn from node to node for each agent. I thought this was cool because then you could see live how this path is adjusted, and additionally how the agent might take shortcuts or how the forces acting on it will cause it to stray from its path.

Note that the starting position of an agent is pink-ish and the goal position of an agent is purple-ish. Once an agent has reached its goal position, a new random goal position is generated and the previous goal position becomes the new starting position. A new path is generated from this new start to this new goal.

--

As a final note, I think this project could be a lot better. I believe the simulation is fairly slow. I neglected to implement a fourth feature from 2b because I was ill and consequently ran out of time. I hope my work in the future of this course can be better than this and I will do my best to ensure that's the case.

## Code

I have a private repository that contains my work for the course. It should be shared with Prof. Guy and Dan. The simulation project should be linked at [csci-5611-animation-and-planning-in-games/assignments/project1/simulation/](https://github.com/alexandra-hanson/csci-5611-animation-and-planning-in-games/tree/main/assignments/project1/simulation).

## Media

I implemented the following features, which you can see in the video below.

<iframe width="560" height="315" src="https://www.youtube.com/embed/wYgd9Fd5ZJM" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

| **Component**      | **Timestamps** |
| ----------- | ----------- |
| Single agent navigation   | 0:16 |
| User Scenario Editing     | 0:07, user adds obstacles by pressing "o" <br> 2:12, user removes obstacles by pressing "p" <br> 0:44, user adds agents by left-clicking <br> 1:34, user removes agents by right-clicking |
| Realtime User Interaction | 1:08, user controls purple obstacle by arrow keys |
| Multiple Agents Planning | 0:50, (also most of the video) |
| Crowd Simulation | 0:34, agents avoid a head-on collision near screen center <br> 0:50, agents avoid angled collision |

## Art Contest Submission

My animation is simple but I still like the way it looks. It kind of reminds me of cells or something.

![](art-contest.png)

## Credit

As you can tell from the video and project repository, my project was pretty simple and I didn't use any libraries. I used the Proj1_Test.pde file provided with the original download from canvas as a jumping off point for constructing the project, and took inspiration from our in-class activities for how to go about coding the desired behavior.

I used [Dijkstra's algorithm](https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm) for the uniform cost search in the path planning library PRM.pde.

I think that is all. It is not very fancy but thank you for reading my report!